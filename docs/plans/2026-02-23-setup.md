# RunTrack Setup ‚Äî Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Cr√©er la structure compl√®te du monorepo RunTrack avec pnpm workspaces, TypeScript strict, Docker Compose, ESLint/Prettier, et des serveurs frontend/backend d√©marrables.

**Architecture:** Monorepo pnpm avec trois workspaces (`frontend`, `backend`, `packages/shared`). Le package `@runtrack/shared` contient les types TypeScript partag√©s (types-only, sans runtime). Le backend expose un endpoint de sant√© `/api/health`, le frontend affiche une page d'accueil bootstrapp√©e.

**Tech Stack:** pnpm workspaces, TypeScript 5, Vite 5, React 18, Express 4, Sequelize 6, PostgreSQL 16, Docker Compose, ESLint 9 (flat config), Prettier 3, Zod 3

---

## Task 1 : Initialisation de la racine du workspace

**Files:**
- Create: `package.json`
- Create: `pnpm-workspace.yaml`
- Create: `.gitignore`
- Create: `tsconfig.base.json`

---

**Step 1 : Cr√©er le fichier `pnpm-workspace.yaml`**

```yaml
packages:
  - 'frontend'
  - 'backend'
  - 'packages/*'
```

**Step 2 : Cr√©er le `package.json` racine**

```json
{
  "name": "runtrack",
  "private": true,
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  },
  "scripts": {
    "dev": "pnpm --parallel -r dev",
    "build": "pnpm -r build",
    "lint": "pnpm -r lint",
    "test": "pnpm -r test",
    "db:up": "docker compose up -d",
    "db:down": "docker compose down",
    "db:logs": "docker compose logs -f postgres"
  },
  "devDependencies": {
    "@eslint/js": "^9.20.0",
    "eslint": "^9.20.0",
    "globals": "^15.14.0",
    "prettier": "^3.5.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.24.0"
  }
}
```

**Step 3 : Cr√©er le `tsconfig.base.json` racine**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "strict": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}
```

**Step 4 : Cr√©er le `.gitignore`**

```gitignore
# Dependencies
node_modules/
.pnpm-store/

# Build outputs
dist/
build/
*.tsbuildinfo

# Environment variables
.env
.env.local
.env.*.local

# Logs
logs/
*.log
npm-debug.log*

# IDE
.vscode/
.idea/
*.swp

# OS
.DS_Store
Thumbs.db

# Docker volumes (local data)
postgres_data/
```

**Step 5 : Installer les d√©pendances racine**

```bash
pnpm install
```

Expected: `Lockfile is up to date, resolution step is skipped` ou cr√©ation de `pnpm-lock.yaml`.

**Step 6 : Commit**

```bash
git init
git add package.json pnpm-workspace.yaml tsconfig.base.json .gitignore
git commit -m "chore: init monorepo root with pnpm workspaces"
```

---

## Task 2 : Package `@runtrack/shared` (types TypeScript partag√©s)

**Files:**
- Create: `packages/shared/package.json`
- Create: `packages/shared/tsconfig.json`
- Create: `packages/shared/src/types/auth.ts`
- Create: `packages/shared/src/types/run.ts`
- Create: `packages/shared/src/types/index.ts`
- Create: `packages/shared/src/index.ts`

---

**Step 1 : Cr√©er `packages/shared/package.json`**

> Concept TypeScript : un package *types-only* n'a aucune d√©pendance runtime. Le champ `"types"` pointe vers les `.d.ts` g√©n√©r√©s. Pattern identique √† `@types/*`.

```json
{
  "name": "@runtrack/shared",
  "version": "0.1.0",
  "private": true,
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc --project tsconfig.json",
    "dev": "tsc --project tsconfig.json --watch"
  },
  "devDependencies": {
    "typescript": "workspace:*"
  }
}
```

**Step 2 : Cr√©er `packages/shared/tsconfig.json`**

> Concept TypeScript : `declaration: true` + `declarationMap: true` g√©n√®re les `.d.ts` et les source maps pour la navigation "go to definition" depuis les workspaces consommateurs.

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "composite": true
  },
  "include": ["src/**/*"],
  "exclude": ["dist", "node_modules"]
}
```

**Step 3 : Cr√©er `packages/shared/src/types/auth.ts`**

```typescript
// Types li√©s √† l'authentification ‚Äî partag√©s frontend/backend
export interface RegisterDto {
  email: string
  password: string
  firstName: string
  lastName: string
}

export interface LoginDto {
  email: string
  password: string
}

// Payload encod√© dans le JWT
export interface JwtPayload {
  userId: number
  email: string
}

// R√©ponse API apr√®s auth r√©ussie (pas le token, il est en cookie httpOnly)
export interface AuthResponse {
  user: {
    id: number
    email: string
    firstName: string
    lastName: string
  }
}
```

**Step 4 : Cr√©er `packages/shared/src/types/run.ts`**

```typescript
// Types li√©s aux courses ‚Äî partag√©s frontend/backend
export type RunStatus = 'completed' | 'draft'

export interface RunDto {
  id: number
  userId: number
  title: string
  date: string           // ISO 8601 string (YYYY-MM-DD)
  distanceKm: number
  durationSeconds: number
  status: RunStatus
  notes: string | null
  createdAt: string
  updatedAt: string
}

export interface CreateRunDto {
  title: string
  date: string
  distanceKm: number
  durationSeconds: number
  status?: RunStatus
  notes?: string
}

export interface UpdateRunDto {
  title?: string
  date?: string
  distanceKm?: number
  durationSeconds?: number
  status?: RunStatus
  notes?: string | null
}

// R√©ponse API pagin√©e pour la liste des courses
export interface RunsListResponse {
  data: RunDto[]
  total: number
  page: number
  pageSize: number
}
```

**Step 5 : Cr√©er `packages/shared/src/types/index.ts`**

```typescript
export * from './auth.js'
export * from './run.js'
```

**Step 6 : Cr√©er `packages/shared/src/index.ts`**

```typescript
export * from './types/index.js'
```

**Step 7 : Installer et builder le package shared**

```bash
pnpm install
pnpm --filter @runtrack/shared build
```

Expected: dossier `packages/shared/dist/` cr√©√© avec `index.js`, `index.d.ts`, `index.d.ts.map`.

**Step 8 : Commit**

```bash
git add packages/
git commit -m "feat: add @runtrack/shared types-only package"
```

---

## Task 3 : Backend Express + TypeScript

**Files:**
- Create: `backend/package.json`
- Create: `backend/tsconfig.json`
- Create: `backend/.env` (ne pas committer)
- Create: `backend/src/config/env.ts`
- Create: `backend/src/app.ts`
- Create: `backend/src/server.ts`

---

**Step 1 : Cr√©er `backend/package.json`**

```json
{
  "name": "backend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc --project tsconfig.json",
    "start": "node dist/server.js",
    "lint": "eslint src --ext .ts",
    "test": "vitest run"
  },
  "dependencies": {
    "@runtrack/shared": "workspace:*",
    "argon2": "^0.41.1",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.13.3",
    "sequelize": "^6.37.5",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/cookie-parser": "^1.4.8",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.8",
    "@types/node": "^22.13.4",
    "@types/pg": "^8.11.11",
    "tsx": "^4.19.2",
    "typescript": "workspace:*",
    "vitest": "^3.0.5"
  }
}
```

**Step 2 : Cr√©er `backend/tsconfig.json`**

> Concept TypeScript : `moduleResolution: NodeNext` est n√©cessaire pour les imports ESM modernes avec Node.js. Il impose les extensions `.js` dans les imports (m√™me pour des fichiers `.ts`).

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "paths": {
      "@runtrack/shared": ["../packages/shared/src/index.ts"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["dist", "node_modules"]
}
```

**Step 3 : Cr√©er `backend/.env` (fichier local, jamais commit√©)**

```dotenv
NODE_ENV=development
PORT=3001
DATABASE_URL=postgresql://runtrack:runtrack@localhost:5432/runtrack
JWT_SECRET=super-secret-dev-key-minimum-32-characters-long
JWT_EXPIRES_IN=7d
```

**Step 4 : Cr√©er `backend/src/config/env.ts`**

> Concept TypeScript + Zod : `z.coerce.number()` convertit la string `"3001"` du `process.env` en `number`. `z.infer<typeof envSchema>` g√©n√®re le type TS depuis le sch√©ma Zod. Si une variable est manquante ou invalide, le process crash au d√©marrage avec un message clair.

```typescript
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.coerce.number().min(1).max(65535).default(3001),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('7d'),
})

// Crash imm√©diat si invalide ‚Äî pas de var undefined en prod
export const env = envSchema.parse(process.env)

export type Env = z.infer<typeof envSchema>
```

**Step 5 : Cr√©er `backend/src/app.ts`**

> Pattern important : s√©parer la cr√©ation de l'app Express (`app.ts`) du d√©marrage du serveur (`server.ts`). Permet de tester l'app sans √©couter sur un port.

```typescript
import cookieParser from 'cookie-parser'
import cors from 'cors'
import express from 'express'
import { env } from './config/env.js'

const app = express()

// Middlewares globaux
app.use(express.json())
app.use(cookieParser())
app.use(
  cors({
    origin: env.NODE_ENV === 'development' ? 'http://localhost:5173' : [],
    credentials: true, // N√©cessaire pour les cookies httpOnly cross-origin
  })
)

// Endpoint de sant√© ‚Äî v√©rifie que l'API r√©pond
app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() })
})

export default app
```

**Step 6 : Cr√©er `backend/src/server.ts`**

```typescript
import app from './app.js'
import { env } from './config/env.js'

app.listen(env.PORT, () => {
  console.log(`üöÄ Backend running on http://localhost:${env.PORT}`)
  console.log(`   Environment: ${env.NODE_ENV}`)
})
```

**Step 7 : Installer les d√©pendances backend**

```bash
pnpm install
```

**Step 8 : V√©rifier que le backend d√©marre**

```bash
pnpm --filter backend dev
```

Expected output :
```
üöÄ Backend running on http://localhost:3001
   Environment: development
```

Tester dans un second terminal :
```bash
curl http://localhost:3001/api/health
```
Expected : `{"status":"ok","timestamp":"..."}`

Stopper avec `Ctrl+C`.

**Step 9 : Commit**

```bash
git add backend/
git commit -m "feat: scaffold backend with Express, TypeScript, env validation"
```

---

## Task 4 : Frontend Vite + React 18 + TypeScript

**Files:**
- Create: `frontend/package.json`
- Create: `frontend/tsconfig.json`
- Create: `frontend/tsconfig.node.json`
- Create: `frontend/vite.config.ts`
- Create: `frontend/index.html`
- Create: `frontend/src/main.tsx`
- Create: `frontend/src/App.tsx`

---

**Step 1 : Cr√©er `frontend/package.json`**

```json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext .ts,.tsx",
    "test": "vitest run"
  },
  "dependencies": {
    "@runtrack/shared": "workspace:*",
    "@tanstack/react-query": "^5.67.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "react-router-dom": "^6.28.2",
    "recharts": "^2.15.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@testing-library/react": "^16.2.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "jsdom": "^26.0.0",
    "typescript": "workspace:*",
    "vite": "^6.1.0",
    "vitest": "^3.0.5"
  }
}
```

**Step 2 : Cr√©er `frontend/tsconfig.json`**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "noEmit": true,
    "paths": {
      "@runtrack/shared": ["../packages/shared/src/index.ts"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

**Step 3 : Cr√©er `frontend/tsconfig.node.json`** (pour Vite lui-m√™me)

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "noEmit": true
  },
  "include": ["vite.config.ts"]
}
```

**Step 4 : Cr√©er `frontend/vite.config.ts`**

```typescript
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Proxy les appels /api vers le backend en dev ‚Äî √©vite les probl√®mes CORS
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
})
```

**Step 5 : Cr√©er `frontend/index.html`**

```html
<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RunTrack</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**Step 6 : Cr√©er `frontend/src/main.tsx`**

> Concept React : `QueryClient` et `QueryClientProvider` wrappent l'app enti√®re pour que TanStack Query soit disponible partout. `RouterProvider` remplace le composant `<App>` quand on ajoute le routing.

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60, // 1 minute
      retry: 1,
    },
  },
})

const rootElement = document.getElementById('root')
if (!rootElement) {
  throw new Error('Root element #root not found in the DOM')
}

createRoot(rootElement).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </StrictMode>
)
```

**Step 7 : Cr√©er `frontend/src/App.tsx`**

```tsx
import { useQuery } from '@tanstack/react-query'

interface HealthResponse {
  status: string
  timestamp: string
}

function App() {
  const { data, isLoading, isError } = useQuery<HealthResponse>({
    queryKey: ['health'],
    queryFn: async () => {
      const res = await fetch('/api/health')
      if (!res.ok) throw new Error('API unreachable')
      return res.json() as Promise<HealthResponse>
    },
  })

  return (
    <main style={{ fontFamily: 'sans-serif', padding: '2rem' }}>
      <h1>RunTrack</h1>
      <p>API status: {isLoading ? '‚è≥ loading...' : isError ? '‚ùå error' : `‚úÖ ${data?.status}`}</p>
    </main>
  )
}

export default App
```

**Step 8 : Installer et d√©marrer le frontend**

```bash
pnpm install
pnpm --filter frontend dev
```

Expected : Vite d√©marre sur `http://localhost:5173`. La page affiche "‚úÖ ok" si le backend tourne en parall√®le.

Stopper avec `Ctrl+C`.

**Step 9 : Commit**

```bash
git add frontend/
git commit -m "feat: scaffold frontend with Vite, React 18, TanStack Query"
```

---

## Task 5 : Docker Compose (PostgreSQL + pgAdmin)

**Files:**
- Create: `docker-compose.yml`
- Create: `.env.example`

---

**Step 1 : Cr√©er `docker-compose.yml`**

```yaml
services:
  postgres:
    image: postgres:16-alpine
    container_name: runtrack-postgres
    restart: unless-stopped
    ports:
      - '5432:5432'
    environment:
      POSTGRES_DB: runtrack
      POSTGRES_USER: runtrack
      POSTGRES_PASSWORD: runtrack
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U runtrack -d runtrack']
      interval: 5s
      timeout: 5s
      retries: 5

  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: runtrack-pgadmin
    restart: unless-stopped
    ports:
      - '5050:80'
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@runtrack.local
      PGADMIN_DEFAULT_PASSWORD: admin
    depends_on:
      postgres:
        condition: service_healthy

volumes:
  postgres_data:
```

**Step 2 : Cr√©er `.env.example`**

```dotenv
# Copier vers backend/.env et remplir les valeurs

NODE_ENV=development
PORT=3001
DATABASE_URL=postgresql://runtrack:runtrack@localhost:5432/runtrack
JWT_SECRET=replace-with-a-random-string-of-at-least-32-characters
JWT_EXPIRES_IN=7d
```

**Step 3 : D√©marrer Docker Compose**

```bash
pnpm db:up
```

Expected : containers `runtrack-postgres` et `runtrack-pgadmin` d√©marr√©s.

**Step 4 : V√©rifier que Postgres est accessible**

```bash
docker compose logs postgres
```

Expected : `database system is ready to accept connections`

**Step 5 : Commit**

```bash
git add docker-compose.yml .env.example
git commit -m "chore: add Docker Compose for PostgreSQL and pgAdmin"
```

---

## Task 6 : ESLint + Prettier (config partag√©e)

**Files:**
- Create: `eslint.config.js`
- Create: `.prettierrc`
- Create: `.prettierignore`

---

**Step 1 : Cr√©er `eslint.config.js`** (flat config ESLint 9)

> Concept : ESLint 9 utilise le "flat config" (`eslint.config.js`) au lieu de `.eslintrc`. La config est un tableau de r√®gles composables. `typescript-eslint` wrapper permet la v√©rification de types TypeScript dans les r√®gles lint.

```javascript
import eslint from '@eslint/js'
import globals from 'globals'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  {
    languageOptions: {
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    // Fichiers JS √† la racine (configs) ‚Äî pas de type-checking
    files: ['*.js', '*.mjs', '*.cjs'],
    ...tseslint.configs.disableTypeChecked,
    languageOptions: {
      globals: globals.node,
    },
  },
  {
    // Ignorer les dossiers g√©n√©r√©s
    ignores: ['**/dist/**', '**/node_modules/**', '**/*.d.ts'],
  }
)
```

**Step 2 : Cr√©er `.prettierrc`**

```json
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5",
  "printWidth": 100,
  "tabWidth": 2
}
```

**Step 3 : Cr√©er `.prettierignore`**

```
dist/
node_modules/
pnpm-lock.yaml
```

**Step 4 : Ajouter scripts lint dans chaque workspace**

Dans `backend/package.json`, le script `lint` est d√©j√† pr√©sent.
Dans `frontend/package.json`, le script `lint` est d√©j√† pr√©sent.

**Step 5 : V√©rifier que le lint passe**

```bash
pnpm lint
```

Expected : aucune erreur. Si des warnings apparaissent sur les fichiers de config bootstrapp√©s, corriger avant de continuer.

**Step 6 : Commit**

```bash
git add eslint.config.js .prettierrc .prettierignore
git commit -m "chore: add ESLint 9 flat config and Prettier"
```

---

## Task 7 : README

**Files:**
- Create: `README.md`

---

**Step 1 : Cr√©er `README.md`**

```markdown
# RunTrack

Application fullstack de suivi de courses √† pied.

## Stack

- **Frontend** : React 18, TypeScript, Vite, React Router v6, TanStack Query v5, React Hook Form, Recharts
- **Backend** : Node.js, Express 4, TypeScript
- **BDD** : PostgreSQL 16 + Sequelize 6
- **Auth** : JWT (httpOnly cookie) + Argon2id
- **Tests** : Vitest + React Testing Library

## Pr√©requis

- Node.js >= 20
- pnpm >= 9
- Docker & Docker Compose

## D√©marrage

### 1. Installer les d√©pendances

\`\`\`bash
pnpm install
\`\`\`

### 2. Configurer les variables d'environnement

\`\`\`bash
cp .env.example backend/.env
# √âditer backend/.env si n√©cessaire
\`\`\`

### 3. D√©marrer la base de donn√©es

\`\`\`bash
pnpm db:up
\`\`\`

### 4. Lancer le projet

\`\`\`bash
pnpm dev
\`\`\`

- Frontend : http://localhost:5173
- Backend API : http://localhost:3001
- pgAdmin : http://localhost:5050 (admin@runtrack.local / admin)

## Scripts disponibles

| Commande | Description |
|----------|-------------|
| `pnpm dev` | Lance frontend + backend en parall√®le |
| `pnpm build` | Build tous les workspaces |
| `pnpm lint` | Lint tous les workspaces |
| `pnpm test` | Tests tous les workspaces |
| `pnpm db:up` | D√©marre PostgreSQL + pgAdmin |
| `pnpm db:down` | Arr√™te les containers |

## Structure

\`\`\`
running-app/
‚îú‚îÄ‚îÄ packages/shared/    # Types TypeScript partag√©s (@runtrack/shared)
‚îú‚îÄ‚îÄ frontend/           # React 18 + Vite
‚îú‚îÄ‚îÄ backend/            # Express + Node.js
‚îî‚îÄ‚îÄ docker-compose.yml
\`\`\`
```

**Step 2 : Commit final**

```bash
git add README.md
git commit -m "docs: add README with setup instructions"
```

---

## V√©rification finale

D√©marrer l'ensemble du projet :

```bash
pnpm db:up
pnpm dev
```

Checklist :
- [ ] `http://localhost:5173` ‚Äî la page React s'affiche avec "‚úÖ ok"
- [ ] `http://localhost:3001/api/health` ‚Äî `{"status":"ok","timestamp":"..."}`
- [ ] `http://localhost:5050` ‚Äî pgAdmin accessible
- [ ] `pnpm lint` ‚Äî aucune erreur
- [ ] `pnpm --filter @runtrack/shared build` ‚Äî dist/ g√©n√©r√©
